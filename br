#!/usr/bin/env python
# -*- encoding: utf-8 -*-

import os
import sys
import codecs
import datetime

import docutils
from docutils.core import publish_string
from docutils.frontend import OptionParser
from docutils.utils import new_document
from docutils.parsers.rst import Parser

try:
    if not sys.stdout.isatty():
        raise ImportError
    import pygments
    import pygments.console
except ImportError:
    def colorize(txt, *a):
        return txt

    styled = colorize
else:
    col_lex = pygments.lexers.get_lexer_by_name('rst')
    col_fmt = pygments.formatters.get_formatter_by_name('terminal')

    def colorize(txt):
        return pygments.highlight(txt, col_lex, col_fmt)

    def styled(txt, how):
        if not how:
            return txt
        if isinstance(how, (list, tuple)):
            mine = how.pop(0)
        else:
            mine = how
            how = None
        return styled(pygments.console.colorize(mine, txt), how)

REVERSE_ORDER = True

try:
    raw_input
except NameError:  # if python3
    unicode = str
else:
    input = raw_input

try:
    import dateutil.parser
except ImportError:
    print("python-dateutil package not installed, start & stop commands will not work!")

CFGDIR = os.path.expanduser('~/.config/bugrest/')
if not os.path.exists(CFGDIR):
    os.mkdir(CFGDIR)
CFGFILE = os.path.join(CFGDIR, 'config.py')
STYLEFILE = os.path.join(CFGDIR, 'style.css')

BUGFILE = 'bugs.rst'
DONEFILE = 'fixed_bugs.rst'
DEBUG = False
SOURCE_MGR = True
TIMER_ATOM = 3600  # number of seconds to add "1" to timer, defaults to 1h

if not os.path.exists(CFGFILE):
    open(CFGFILE, 'w').write('''# sample config, Python syntax
BUGFILE="%s"
DONEFILE="%s"
DEBUG=%s
SOURCE_MGR=%s
''' % (
       BUGFILE,
       DONEFILE,
       DEBUG,
       SOURCE_MGR
    ))

exec(open(CFGFILE).read())


def now(iso=True):
    r = datetime.datetime.now()
    if iso:
        r = r.isoformat().rsplit('.', 1)[0]
    return r


def read_paragraph(prefix=''):
    blanklines = 0
    for n in range(200):
        text = input(prefix)
        if not text:
            blanklines += 1
            if blanklines == 2:
                break
            yield ''
            continue
        blanklines = 0
        yield text

# For later if needed ? to create documents from nodes...
# http://agateau.com/2015/docutils-snippets/


class Bug:
    line_start = 0
    field_line = 0
    nb_comments = 0
    original_text = ''

    def __init__(self, title):
        self.title = title.strip()
        self.description = ''
        self.comments = []
        self.attributes = {}

    @property
    def id(self):
        return int(self['bugid'] or -42)

    @property
    def started(self):
        return 'started' in self.attributes

    def string_as_list(self, i):
        return " %s %s%3s [%d] %s" % (
                styled(self['tags'].replace('#', ' ').center(20, ' '), 'teal'),
                self.started and '*' or ' ',
                styled(str(i+1), 'bold'),
                self.nb_comments,
                styled(self.title, ['standout', 'yellow']),
                )

    def __str__(self):
        r = []
        r.append(self.title)
        r.append("#"*len(self.title))
        r.append('')
        for k, v in self.attributes.items():
            r.append(':%s: %s' % (k, v))
        r.append('')
        stripped = self.field_line - self.line_start
        r.append('\n'.join(self.original_text.split('\n')[stripped:]))
        return '\n'.join(r).rstrip('\n')

    def add_tag(self, tagname):
        mytags = self['tags'].split('#')
        tags = set(x.strip() for x in mytags if x)
        tags.add(tagname)
        self['tags'] = '#' + '#'.join(tags)

    def rm_tag(self, tagname):
        mytags = self['tags'].split('#')
        tags = set(x.strip() for x in mytags if x)
        tags.remove(tagname)
        if tags:
            self['tags'] = '#' + '#'.join(tags)
        else:
            self['tags'] = ''

    @property
    def priority(self):
        return int(self.attributes.get('priority', 0))

    def __delitem__(self, name):
        del self.attributes[name]

    def __getitem__(self, name):
        return self.attributes.get(name, '')

    def __setitem__(self, name, val):
        self.attributes[name.rstrip().lower()] = str(val).rstrip()


class Visitor(docutils.nodes.GenericNodeVisitor):

    def __init__(self, doc, bugs):
        line_mapping = {}
        previous = None

        for i, pos in enumerate(b.line_stop for b in bugs):
            if i:
                r = range(previous, pos)
            else:
                r = range(pos)
            for line in r:
                line_mapping[line] = bugs[i]
            previous = pos

        self.line_mapping = line_mapping
        docutils.nodes.GenericNodeVisitor.__init__(self, doc)

    def visit_definition_list_item(self, node):
        b = self.line_mapping[node.line]
        b.nb_comments += 1

    def visit_field(self, node):  # attributes
        b = self.line_mapping[node.line]
        b[node.children[0].astext().strip()] = node.children[1].astext().strip()
        b.field_line = max(getattr(self, 'field_line', 0), node.line)

    def default_visit(self, node):
        if DEBUG:
            print("=", node.tagname)
            print("[[%s]]" % node.rawsource)


class FileHandler:

    def __init__(self):
        self.bugs = []
        self.fixed_bugs = []
        self.info = None
        self.bugs_text = []
        self.load()

    def get(self, nr):
        return self.bugs[nr]

    def save(self, done=False):
        if done:
            fname = DONEFILE
            source = self.fixed_bugs
        else:
            fname = BUGFILE
            source = [self.info] + self.bugs

        data = []
        for i, bug in enumerate(source):
            data.append(str(bug))
            if i+1 != len(source):
                data.append("\n\n%s\n\n" % ("-"*80))  # separator on single line
        # save only if didn't except before
        data.append('\n')
        o = codecs.open(fname, 'w', encoding='utf-8')
        o.writelines(data)
        o.close()

    def load(self, done=False):
        if done:
            fname = DONEFILE
            source = self.fixed_bugs
        else:
            fname = BUGFILE
            source = self.bugs

        if os.path.exists(fname):
            parser = Parser()
            settings = OptionParser(components=(Parser,)).get_default_values()
            document = new_document(fname, settings)
            text = codecs.open(fname, encoding='utf-8').read()
            text_lines = text.split('\n')
            parser.parse(text, document)

            def deepest(node, which=-1):
                try:
                    line = node[which].line
                except IndexError:
                    return node.line or -1

                if line:
                    return deepest(node[which]) or -1
                return node.line

            for i, section in enumerate(document):
                try:
                    start = deepest(section[0], 0)
                    stop = deepest(section[-1])+1
                    title = text_lines[start-2]
                    orig_text = text_lines[start:stop]
                except:
                    import pudb
                    pu.db
                else:
                    b = Bug(title)
                    b.original_text = '\n'.join(orig_text).strip()
                    if b.original_text.endswith('-----'):
                        b.original_text = b.original_text.rstrip('-')
                    b.line_start = start
                    b.line_stop = stop

                    if not i and not done:
                        self.info = b
                        self.info.attributes.setdefault('count', 0)
                    else:
                        if done:
                            self.fixed_bugs.append(b)
                        else:
                            self.bugs.append(b)

            if done:
                visitor = Visitor(document, self.fixed_bugs)
            else:
                visitor = Visitor(document, [self.info] + self.bugs)
            document.walk(visitor)

            if not done:  # sort bugs
                if REVERSE_ORDER:
                    def sorting(x):
                        return x.priority+1/(1+x.id)
                else:
                    def sorting(x):
                        return x.priority
                source.sort(key=sorting)

        if not self.info:
            self.info = Bug('Tickets')
            self.info['count'] = 0

    def new_bug(self, bug):
        bug['created'] = now()
        bug['bugid'] = self.info['count']
        self.info['count'] = int(self.info['count']) + 1
        self.bugs.append(bug)
        self.save()

    def mark_started(self, bugid):
        bug = self.get(bugid)
        bug['started'] = now()
        self.save()

    def mark_stopped(self, bugid):
        if isinstance(bugid, int):
            bug = self.get(bugid)
        else:
            bug = bugid
        if bug['started']:
            if not bug['timer']:
                old = 0
            else:
                old = int(bug['timer'])

            last_date = dateutil.parser.parse(bug['started'])
            old += ((now(False) - last_date).seconds/TIMER_ATOM)
            del bug['started']
            bug['timer'] = int(old)
            self.save()
        else:
            print('Already stopped')

    def mark_fixed(self, bugid):
        bug = self.bugs.pop(bugid)
        if bug['started']:
            self.mark_stopped(bug)
        bug['fixed'] = now()
        self.fixed_bugs.insert(0, bug)
        self.save()
        self.save(True)

    def __iter__(self):
        return iter(self.bugs)

    def __len__(self):
        return len(self.bugs)


if __name__ == '__main__':
    if SOURCE_MGR:
        fold = os.path.abspath(os.path.curdir)
        found = None
        current_path = ''
        for fold in fold.split(os.path.sep):
            if fold:
                current_path += fold + os.path.sep
                # norm
            else:
                current_path += os.path.sep
            for scm in 'svn hg git bzr'.split():
                if os.path.isdir("%s.%s" % (current_path, scm)):
                    found = current_path
        if found:
            os.chdir(found)

    handler = FileHandler()

    try:
        cmd = sys.argv[1]
    except IndexError:
        cmd = 'list'
    else:
        args = sys.argv[2:]

    if cmd == 'list' or cmd == 'ls':
        for i, bug in enumerate(handler):
            print(bug.string_as_list(i))
    elif cmd.startswith('prio'):
        prio = int(args[0])
        for i, bug in enumerate(handler):
            if bug.priority >= prio:
                print(bug.string_as_list(i))
    elif cmd.startswith('show'):
        try:
            nr = int(args[0])-1
        except IndexError:
            nr = None

        if nr is not None:
            print(colorize(unicode(handler.get(nr))))
        else:
            for i, bug in enumerate(handler):
                print(colorize(unicode(bug)))
                print('')
    elif cmd == 'grep':
        for i, bug in enumerate(handler):
            text = str(bug).lower()
            count = 0
            for pattern in args:
                if pattern.lower() in text:
                    count += 1
            if count == len(args):
                print(bug.string_as_list(i))

    elif cmd == 'untag':
        bug_nr = int(args[0])-1
        tagname = args[1]
        handler.get(bug_nr).rm_tag(tagname)
        handler.save()
    elif cmd == 'tag':
        try:
            tagname = args[1]
        except:
            tagname = args[0]
            bug_nr = None
        else:
            bug_nr = int(args[0])-1

        if bug_nr is not None:
            bug = handler.get(bug_nr)
            bug.add_tag(tagname)
            handler.save()
        else:
            for i, bug in enumerate(handler):
                if tagname in bug['tags']:
                    print(bug.string_as_list(i))
    elif cmd == 'start':
        try:
            nr = int(args[0])
        except IndexError:
            nr = input('nr: ')
        handler.mark_started(int(nr)-1)
    elif cmd == 'stop':
        try:
            nr = int(args[0])
        except IndexError:
            nr = input('nr: ')
        handler.mark_stopped(int(nr)-1)
    elif cmd == 'del' or cmd == 'rm':
        try:
            nr = int(args[0])
        except IndexError:
            nr = input('nr: ')
        handler.load(True)  # loads current fixed bugs list too
        handler.mark_fixed(int(nr)-1)
    elif cmd == 'add':
        try:
            nr = int(args[0])
        except IndexError:
            nr = input('nr: ')
        bug = handler.get(nr-1)

        description = input('Title: ').rstrip()
        comment_text = [description]
        for line in read_paragraph('Comment: '):
            comment_text.append('    ' + line)
        bug.original_text += '\n\n' + ('\n'.join(comment_text).rstrip())
        handler.save()
    elif cmd == 'html':
        text = codecs.open(BUGFILE, encoding='utf-8').read()
        text = text.rstrip().rstrip('-')
        print(publish_string(text, writer_name='html', settings_overrides={
            'stylesheet_path': STYLEFILE  # Replace with a pkg_resource thing or another hack to get data
            }))
    elif cmd == 'new':
        title = input('Title: ').rstrip()
        bug = Bug(title)
        blanklines = 0
        full_description = []
        for n in range(200):
            description = input('Description: ')
            if not description:
                blanklines += 1
                if blanklines == 2:
                    break
                full_description.append('')
                continue
            blanklines = 0
            full_description.append(description)
        full_description.append('')
        full_description.append('-'*10)
        bug.original_text = '\n'.join(full_description)
        bug['priority'] = '0'
        bug['bugid'] = handler.info['count']
        bug['created'] = now()
        handler.new_bug(bug)
    else:
        print("Commands:")
        docs = """\
    list: short listing of bugs (default action)
    show: detailed listing of bugs, ReStructuredText format (save as .rst or .txt)
    html: same as above, but in html format
     new: open a new bug
      rm: remove some bug (mark as fixed)
     add: add some comment to a bug
   start: starts counting elapsed time for this bug
    stop: stops counting elapsed time for this bug
     tag: adds a tag to a bug
   untag: removes a tag
    grep: list bugs containing given pattern(s)"""
        for doc in docs.split('\n'):
            name, desc = doc.split(': ', 1)
            print("%s: %s" % (styled(name, 'blue'), desc))
        print(styled("""
Examples:
user@host:~$ %(prog)s
   10  - red looks green
   21  - missing image
   37  - doc needs review
user@host:~$ echo -e "test bug\\nsimple description\\n" | %(prog)s new
user@host:~$ %(prog)s show | rst2pdf  > buglist.pdf
user@host:~$ echo "Fixed in #4242" | %(prog)s add 21 && %(prog)s rm 21
                """ % dict(prog=sys.argv[0].rsplit('/', 1)[-1]), 'standout'))
