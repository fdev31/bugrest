#!/usr/bin/env python
# -*- encoding: utf-8 -*-
" A simple command-line ticket tracker "

import os
import re
import sys
import codecs
import datetime

import docutils
from docutils.core import publish_string
from docutils.frontend import OptionParser
from docutils.utils import new_document
from docutils.parsers.rst import Parser

# black background:
YELLOW = 'yellow'

JTAG = re.compile('{[^}]+}')
JID = 'jira-id'
try:
    if not sys.stdout.isatty():
        raise ImportError
    import pygments
    import pygments.console
except ImportError:
    # stubs
    def colorize(txt, *a):
        return txt
    styled = colorize
else:
    def colorize(txt):
        """ Colorize *ReStructuredText* for a Terminal

        :arg str txt: The *ReStructuredText* content
        :returns: Colorized string"""
        col_lex = pygments.lexers.get_lexer_by_name('rst')
        col_fmt = pygments.formatters.get_formatter_by_name('terminal')
        return pygments.highlight(txt, col_lex, col_fmt)

    def styled(txt, how):
        """ Apply a list of styles to some text

        :arg str txt: text to be styled
        :arg list(str) how: list of styles to apply
        :returns: colorized string for terminal
        """
        if not how:
            return txt
        if isinstance(how, (list, tuple)):
            mine = how.pop(0)
        else:
            mine = how
            how = None
        return styled(pygments.console.colorize(mine, txt), how)


try:
    raw_input
except NameError:  # if python3
    unicode = str
else:
    input = raw_input

try:
    import dateutil.parser
except ImportError:
    print("python-dateutil package not installed, start & stop commands will not work!")

try:
    from html.parser import HTMLParser
except ImportError:
    from HTMLParser import HTMLParser

class MLStripper(HTMLParser):
    def __init__(self):
        super().__init__()
        self.reset()
        self.fed = []
    def handle_data(self, d):
        self.fed.append(d)
    def get_data(self):
        return ''.join(self.fed)

def strip_tags(html):
    s = MLStripper()
    s.feed(html)
    return s.get_data()

CFGDIR = os.path.expanduser('~/.config/bugrest/')
if not os.path.exists(CFGDIR):
    os.mkdir(CFGDIR)

STYLEFILE = os.path.join(CFGDIR, 'style.css')
JSCODEFILE = os.path.join(CFGDIR, 'code.js')
if not os.path.exists(JSCODEFILE):
    import shutil
    import bugrest
    shutil.copy(
        os.path.join(os.path.dirname(bugrest.__file__), 'style.css'),
        STYLEFILE)
    shutil.copy(
        os.path.join(os.path.dirname(bugrest.__file__), 'code.js'),
        JSCODEFILE)

CFGFILE = os.path.join(CFGDIR, 'config.py')

GLOBAL_COUNTER_NAME = 'total-count'
REVERSE_ORDER = False
HTTP_PORT = 5555
BUGFILE = 'bugs.rst'
DONEFILE = 'fixed_bugs.rst'
DEBUG = False
SOURCE_MGR = True
USE_PAGER = True
TIMER_ATOM = 3600  # number of seconds to add "1" to timer, defaults to 1h
WHITE_BACKGROUND = False
SHORT_DISPLAY = False
JIRA_DISPLAY = False

if not os.path.exists(CFGFILE):
    open(CFGFILE, 'w').write('''# sample config, Python syntax
BUGFILE="%s"
DONEFILE="%s"
DEBUG=%s
SOURCE_MGR=%s
REVERSE_ORDER=%s
USE_PAGER=%s
HTTP_PORT=%s
CSS=%s
JS=%s
WHITE_BACKGROUND=%s
''' % (
    BUGFILE,
    DONEFILE,
    DEBUG,
    SOURCE_MGR,
    REVERSE_ORDER,
    USE_PAGER,
    HTTP_PORT,
    STYLEFILE,
    JSCODEFILE,
    WHITE_BACKGROUND,
    ))

exec(open(CFGFILE).read())

if WHITE_BACKGROUND:
    YELLOW = 'red'

from io import StringIO
import subprocess

class Pager:
    def __init__(self, cmd=['less', '-iFRX']):
        self.cmd = cmd

    def __enter__(self):
        self.oldstdout = sys.stdout
        sys.stdout = StringIO()

    def __exit__(self, *a):
        sys.stdout.seek(0)
        text_data = sys.stdout.read().encode('utf-8')
        sys.stdout = self.oldstdout

        p = subprocess.Popen(self.cmd, bufsize=1, stdin=subprocess.PIPE)
        p.communicate(text_data)

class NullPager:
    def __enter__(self):
        pass
    def __exit__(self):
        pass

if not USE_PAGER:
    Pager = NullPager

def now(iso=True):
    """ Returns a string representing current time """
    r = datetime.datetime.now()
    if iso:
        r = r.isoformat().rsplit('.', 1)[0]
    return r


def read_paragraph(prefix=''):
    """ Reads a paragraph """
    blanklines = 0
    for _ in range(200):
        text = input(prefix)
        if not text:
            blanklines += 1
            if blanklines == 2:
                break
            yield ''
            continue
        blanklines = 0
        yield text

# For later if needed ? to create documents from nodes...
# http://agateau.com/2015/docutils-snippets/


JIRA_ACTION = 'customfield_10947'
JIRA_TECHBA = 'customfield_17130'
JIRA_IASTATUS = 'customfield_18033'

class Bug:
    """ Bug object, also used to store infos
    A Bug .rst file is a list of Bug objects

    The conversion happens in the :func:`load` method, called on init.
    """
    line_start = 0
    field_line = 0
    original_text = ''
    title_char = '='
    property_trans = {
            JIRA_ACTION : 'action',
            JIRA_TECHBA : 'TechBA',
            JIRA_IASTATUS : 'IA status',
            }

    def __init__(self, title):
        self.title = title.strip()
        self.description = ''
        self.comments = []
        self.attributes = {}

    @property
    def uid(self):
        return int(self['bugid'] or -42)

    @property
    def started(self):
        return 'started' in self.attributes

    def string_as_list(self, i):
        if JIRA_DISPLAY:
            return '%s:%s'%(JID, self[JID])

        if SHORT_DISPLAY:
            return '#%s'%self.uid

        return "%s%s%s #%d%s" % (
                styled('*', 'bold') if self.started else ' ',
                styled(str(i).ljust(3), 'bold'),
            styled(self.title, ['standout', YELLOW if self.started else 'blue']),
            self.uid,
            styled(self['tags'].replace('#', ' ') + ''*(20-len(self['tags'])), 'teal'),
            )

    def __str__(self):
        r = []
        r.append(self.title)
        r.append(self.title_char*len(self.title))
        r.append('')
        for k, v in sorted(self.attributes.items()):
            r.append(':%s: %s' % (self.property_trans.get(k, k), v))
        stripped = self.field_line - self.line_start
        r.append('\n'.join(self.original_text.split('\n')[stripped:]))
        return '\n'.join(r).rstrip('\n')

    @property
    def tags(self):
        mytags = self['tags'].split('#')
        return set(x.strip() for x in mytags if x)

    def add_tag(self, tagname):
        tags = self.tags
        tags.add(tagname)
        self['tags'] = '#' + '#'.join(tags)

    def rm_tag(self, tagname):
        tags = self.tags
        tags.remove(tagname)
        if tags:
            self['tags'] = '#' + '#'.join(tags)
        else:
            self['tags'] = ''

    @property
    def priority(self):
        return int(self.attributes.get('priority', '0').split(None, 1)[0])

    def __delitem__(self, name):
        try:
            del self.attributes[name]
        except KeyError:
            raise RuntimeError('No such attribute "%s"' % name)

    def __getitem__(self, name):
        return self.attributes.get(name, '')

    def __setitem__(self, name, val):
        self.attributes[name.rstrip().lower()] = str(val).rstrip()


class Visitor(docutils.nodes.GenericNodeVisitor):

    default_departure = None

    def __init__(self, doc, bugs):
        line_mapping = {}
        previous = None

        for i, pos in enumerate(b.line_stop+1 for b in bugs):
            if i:
                r = range(previous, pos)
            else:
                r = range(pos)
            for line in r:
                line_mapping[line] = bugs[i]
            previous = pos

        self.line_mapping = line_mapping
        docutils.nodes.GenericNodeVisitor.__init__(self, doc)

    def visit_field(self, node):  # attributes
        b = self.line_mapping[node.line]
        b[node.children[0].astext().strip()] = node.children[1].astext().strip()
        b.field_line = max(getattr(self, 'field_line', 0), node.line)

    def default_visit(self, node):
        if DEBUG:
            print("=", node.tagname)
            print("[[%s]]" % node.rawsource)


class FileHandler:

    def __init__(self):
        self.bugs = []
        self.fixed_bugs = []
        self.info = None
        self.bugs_text = []
        self.mixed_priorities = False
        self.load()
        self.line_stop = None
        self.line_start = None

    @property
    def single_priority(self):
        return all(x.priority == 0 for x in self)

    def get(self, nr):
        notfound_txt = 'Invalid bug id'
        if not nr:
            raise RuntimeError(notfound_txt)
        if isinstance(nr, str) and not nr.isdigit():
            if nr[0] == '#':
                k = 'bugid'
                v = nr[1:]
            elif ':' in nr:
                k, v = nr.split(':')
            else:
                raise RuntimeError(notfound_txt)
            for bug in self:
                if bug[k] == v:
                    return bug
        else:
            nr = int(nr)
            try:
                return self.bugs[nr]
            except IndexError:
                raise RuntimeError(notfound_txt)

        raise RuntimeError(notfound_txt)

    def save(self, done=False):
        if done:
            fname = DONEFILE
            source = self.fixed_bugs
        else:
            fname = BUGFILE
            source = [self.info] + self.bugs

        data = []
        for i, bug in enumerate(source):
            data.append(str(bug))
            if i+1 != len(source):
                data.append("\n\n%s\n\n" % ("-"*80))  # separator on single line
        # save only if didn't except before
        data.append('\n')
        o = codecs.open(fname, 'w', encoding='utf-8')
        o.writelines(data)
        o.close()

    def load(self, done=False):
        if done:
            fname = DONEFILE
            source = self.fixed_bugs
        else:
            fname = BUGFILE
            source = self.bugs

        if os.path.exists(fname):
            parser = Parser()
            settings = OptionParser(components=(Parser,)).get_default_values()
            document = new_document(fname, settings)
            text = codecs.open(fname, encoding='utf-8').read()
            text_lines = text.split('\n')
            parser.parse(text, document)
            indices = [i for i, l in enumerate(text_lines) if l.startswith('------')]

            start = 0
            for i in range(len(document)):
                if i:
                    start = indices[i - 1] + 2
                    title = text_lines[start]
                else:
                    title = text_lines[0]
                start += 3
                if i+1 == len(document):
                    stop = len(text_lines) - 1
                else:
                    stop = indices[i] - 1
                orig_text = text_lines[start:stop]
                b = Bug(title)
                b.original_text = '\n'.join(orig_text).strip()
                if b.original_text.endswith('-----'):
                    b.original_text = b.original_text.rstrip('-')
                b.line_start = start
                b.line_stop = stop

                if not i and not done:
                    self.info = b
                else:
                    if done:
                        self.fixed_bugs.append(b)
                    else:
                        self.bugs.append(b)

            if done:
                visitor = Visitor(document, self.fixed_bugs)
            else:
                visitor = Visitor(document, [self.info] + self.bugs)
            document.walk(visitor)

            if not done:  # sort bugs
                if REVERSE_ORDER:
                    def sorting(x):
                        return (-x.priority, x.uid)
                else:
                    def sorting(x):
                        return (x.priority, x.uid)
                source.sort(key=sorting)

        if not self.info:
            self.info = Bug('Tickets')
            self.info[GLOBAL_COUNTER_NAME] = 0

    def new_bug(self, bug):
        bug['created'] = now()
        cnt = int(self.info[GLOBAL_COUNTER_NAME])
        bug['bugid'] = cnt + 1
        self.info[GLOBAL_COUNTER_NAME] = cnt + 1
        self.bugs.append(bug)
        self.save()
        return bug.uid

    def mark_started(self, bugid):
        bug = self.get(bugid)
        bug['started'] = now()
        self.save()

    def mark_stopped(self, bugid):
        bug = self.get(bugid)
        if bug['started']:
            if not bug['timer']:
                old = 0
            else:
                old = int(bug['timer'])

            last_date = dateutil.parser.parse(bug['started'])
            old += ((now(False) - last_date).seconds/TIMER_ATOM)
            del bug['started']
            bug['timer'] = int(old)
            self.save()
        else:
            print('Already stopped')

    def mark_fixed(self, bugid):
        bug = self.get(bugid)
        self.bugs.pop(self.bugs.index(bug))
        if bug['started']:
            self.mark_stopped(bug)
        bug['fixed'] = now()
        self.fixed_bugs.insert(0, bug)
        self.save()
        self.save(True)

    def __iter__(self):
        return iter(self.bugs)

    def __len__(self):
        return len(self.bugs)

# All commands

def cmd_jdump(handler, bugid):
    jira = get_jira_object()
    bugid = bugid.rstrip('_,')
    if bugid.startswith(JID):
        bugid = bugid[len(JID)+1:]
    jbug = jira.issue(bugid)
    with Pager():
        for field in dir(jbug.fields):
            v = getattr(jbug.fields, field)
            if field[0] == '_' or not v:
                continue
            print(styled("%s::"%field, 'bold'))
            print("  %s"%v)

def cmd_pull(handler, *bugids):
    if not bugids:
        bugids = [b for b in (bug[JID] for bug in handler) if b]
        print("Upading %d bugs"%len(bugids))

    jira = get_jira_object()
    for bugid in bugids:
        bugid = bugid.rstrip('_,')
        if bugid.startswith(JID):
            bugid = bugid[len(JID)+1:]
        jbug = jira.issue(bugid)
        create_new = False
        bug_links = set([jbug.key])
        url_prefix = jbug.permalink().rsplit('/', 1)[0]

        def linkify(bugid):
            bug_links.add(bugid)
            return "%s_" % bugid

        bug_title = "%s %s"%(linkify(jbug.key), jbug.fields.summary)
        for b in handler:
            if b[JID] == bugid:
                bug = b
                bug.title = bug_title
                break
        else:
            bug = Bug(bug_title)
            bug[JID] = bugid
            create_new = True

        for field in 'status issuetype customfield_10947'.split():
            v = getattr(jbug.fields, field)
            if isinstance(v, (list, tuple)):
                v = v[0]
            bug[field] = v
        all_text = [
                "\n\n.. decoded text:\n\n%s\n" % '\n'.join("        "+l for l in strip_tags(jbug.fields.description).split('\n')),
                "\n\n.. raw:: html\n\n%s\n" % '\n'.join("        "+l for l in jbug.fields.description.split('\n')),
                ''
                ]
        inwards = []
        outwards = []
        for link in jbug.fields.issuelinks:
            if 'inwardIssue' in link.raw:
                inwards.append(dict(link.raw['inwardIssue']))
            if 'outwardIssue' in link.raw:
                outwards.append(dict(link.raw['outwardIssue']))

        for title, kind in ('Implements', outwards), ('Is implemented by', inwards):
            if kind:
                all_text.append("\n%s:\n"%title)
                for link in sorted(kind, key=lambda x: x['key']):
                    all_text.append('- [{bugtype}] {bugid} {summary} '.format(
                        bugtype=link['fields']['issuetype']['name'],
                        bugid=linkify(link['key']),
                        summary=link['fields']['summary']
                        ))

        if bug_links:
            all_text.append('')
        for link in bug_links:
            all_text.append('.. _%s: %s/%s'%(link, url_prefix, link))

        bug.original_text = '\n'.join(all_text)
        bug.line_start = 0
        bug.field_line = 0
        if create_new:
            handler.new_bug(bug)
    handler.save()


def cmd_filter(handler, *filters):
    var_sep = '='
    compiled_filters = []
    for filt_pat in filters:
        if var_sep in filt_pat:
            filt_key, filt_pat = (x.strip() for x in filt_pat.split(var_sep))
            regex = re.compile(filt_pat)
            if filt_key == 'title':
                compiled_filters.append( lambda bug: regex.match(bug.title ) )
            else:
                compiled_filters.append( lambda bug: regex.match(bug[filt_key] ) )
    for i, bug in enumerate(handler):
        if all(f(bug) for f in compiled_filters):
            print(bug.string_as_list(i))

def cmd_list(handler):
    priority = None
    show_priorities = not handler.single_priority
    max_bugid = 0
    verbose = not (JIRA_DISPLAY or SHORT_DISPLAY)
    for i, bug in enumerate(handler):
        if verbose and show_priorities and bug.priority != priority:
            priority = bug.priority
            print(styled("P%s:" % priority, YELLOW))
        max_bugid = max(max_bugid, bug.uid)
        print(bug.string_as_list(i))
    if max_bugid == 0 and len(handler) == 0 and verbose:
        print("Nothing to show here!")
    else:
        nb_fixed = 1+max_bugid-len(handler)
        nb_active = len(handler)
        if verbose:
            print("> Fixed %s bugs, %s active, latest is #%d"%(
                styled(str(nb_fixed), 'yellow'),
                styled(str(nb_active), 'brown'),
                max_bugid
            ))


cmd_ls = cmd_list


def cmd_show(handler, *nrs):
    def process(bug):
        print(colorize(unicode(bug).replace(u'raw:: html', u'code:: html')))

    with Pager():
        if not nrs:
            for bug in reversed(list(handler)):
                process(bug)
                print('')
        else:
            for nr in nrs:
                bug = handler.get(nr)
                process(bug)


def cmd_grep(handler, *args):
    for i, bug in enumerate(handler):
        text = str(bug).lower()
        count = 0
        for pattern in args:
            if pattern.lower() in text:
                count += 1
        if count == len(args):
            print(bug.string_as_list(i))


def cmd_untag(handler, bug_nr, tagname):
    handler.get(bug_nr).rm_tag(tagname)
    handler.save()


def cmd_tag(handler, bug_nr=None, tagname=None):
    if bug_nr is None:
        # Just list
        all_tags = set()
        for bug in handler:
            all_tags = all_tags.union(bug.tags)
        for tag in sorted(all_tags):
            print(" %s"%tag)
        return


    if not tagname:
        tagname = bug_nr
        bug_nr = None

    if bug_nr is not None:
        bug = handler.get(bug_nr)
        bug.add_tag(tagname)
        handler.save()
    else:
        for i, bug in enumerate(handler):
            if tagname in bug['tags']:
                print(bug.string_as_list(i))


def cmd_start(handler, nr=None):
    if nr is None:
        nr = input('nr: ')
    handler.mark_started(nr)


def cmd_stop(handler, nr=None):
    if nr is None:
        nr = input('nr: ')
    handler.mark_stopped(nr)


def cmd_remove(handler, *nrs):
    handler.load(True)  # loads current fixed bugs list too
    for nr in nrs:
        handler.mark_fixed(nr)

cmd_fix = cmd_delete = cmd_rm = cmd_remove


def cmd_log(handler):
    # templatable log
    prio_n1 = None
    for bug in handler:
        if bug['jira-id'].startswith('ONEMUI') and bug['status'] != 'Rejected':
            if prio_n1 != bug.priority:
                print("")
            print("https://jira.upc.biz/browse/%s [%s]"%(bug.title, bug['status']))
            prio_n1 = bug.priority


def cmd_add(handler, nr=None):
    if nr is None:
        nr = input('nr: ')
    bug = handler.get(nr)

    description = input('Title: ').rstrip()
    comment_text = [description]
    for line in read_paragraph('Comment: '):
        comment_text.append('    ' + line)
    bug.original_text += '\n\n' + ('\n'.join(comment_text).rstrip())
    handler.save()


def cmd_html(handler):
    text = codecs.open(BUGFILE, encoding='utf-8').read()
    text = text.rstrip().rstrip('-')
    print(publish_string(text, writer_name='html', settings_overrides={
        'stylesheet_path': STYLEFILE  # Replace with a pkg_resource thing or another hack to get data
        }))


def cmd_new(handler, title=None, description=None):
    if title is None:
        title = input('Title: ').rstrip()
    bug = Bug(title)
    if description:
        full_description = description
    else:
        full_description = []
        for line in read_paragraph('Description: '):
            if not full_description:
                line = line.strip()
            full_description.append(line)
    full_description.append('')
    bug.original_text = '\n' + '\n'.join(full_description)
    bug['priority'] = '0'
    print("created #%d"% handler.new_bug(bug))


def cmd_unset(handler, nr, name=None):
    bug = handler.get(nr)
    if name is None:
        name = input('Attribute name: ').strip()
    if not bug:
        raise RuntimeError("Bug not found")
    del bug[name]
    handler.save()
    print(colorize(unicode(bug)))


def cmd_get(handler, nr, name=None):
    bug = handler.get(nr)
    if name is None:
        name = input('Attribute name: ').strip()
    print("%s: %s" % (styled(name, YELLOW), styled(bug[name], 'bold')))


def cmd_set(handler, nr, name=None, value=None):
    bug = handler.get(nr)

    if name is None:
        name = input('Attribute name: ').strip()
    if value is None:
        value = input('Value: ').strip()

    bug[name] = value
    handler.save()
    print(colorize(unicode(bug)))


def cmd_serve(handler, port=HTTP_PORT):
    import socket
    port = int(port)
    # python3 first:
    try:
        import socketserver
    except ImportError:
        import SocketServer as socketserver

    try:
        import http.server as SimpleHTTPServer
    except ImportError:
        import SimpleHTTPServer # python2


    class BasicTCPServer(socketserver.ThreadingTCPServer):
        def server_bind(self):
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            socketserver.ThreadingTCPServer.server_bind(self)

    class HTTPHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
        def do_GET(self):

            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()

            handler = FileHandler()
            handler.info.title_char = '#'
            text = []

            text.append(unicode(handler.info))
            text.append(u'''
.. contents::
    :local:
            ''')

            text.append('''.. raw:: html

        <select class="filter_input" id="filter_name">
            <option value=""></option>
        </select><input class="filter_input" type="text" id="filter_value" /><button onclick="run_filter()">Filter</button>
        <input type="hidden" id="header_limit"></input>
            ''')

            for bug in reversed(list(handler)):
                text.append(unicode(bug))
                text.append(u'')

            text.append(u'')
            text.append(u'.. raw:: html')
            text.append(u'')
            text.append(u'    <script>')
            text.extend(u'    '+line.rstrip() for line in open(JSCODEFILE).readlines())
            text.append(u'    </script>')
            if DEBUG:
                print('\n'.join(text))

            self.wfile.write(publish_string('\n'.join(text), writer_name='html', settings_overrides={
                'stylesheet_path': STYLEFILE  # Replace with a pkg_resource thing or another hack to get data
                }))
            return

    httpd = BasicTCPServer(('0.0.0.0', port), HTTPHandler)
    try:
        print("HTTP server on port %s" % port)
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("... bye bye!")


def main():
    if SOURCE_MGR: # track .<vcs> files as root if option enabled
        fold = os.path.abspath(os.path.curdir)
        found = None
        current_path = ''
        for fold in fold.split(os.path.sep):
            if fold:
                current_path += fold + os.path.sep
                # norm
            else:
                current_path += os.path.sep
            for scm in 'svn hg git bzr'.split():
                if os.path.isdir("%s.%s" % (current_path, scm)):
                    found = current_path
        if found:
            os.chdir(found)

    if '-q' in sys.argv:
        global SHORT_DISPLAY
        sys.argv.pop(sys.argv.index('-q'))
        SHORT_DISPLAY = True
    if '-j' in sys.argv:
        global JIRA_DISPLAY
        sys.argv.pop(sys.argv.index('-j'))
        JIRA_DISPLAY = True

    try:
        cmd = sys.argv[1]
        if cmd.endswith('.rst'):
            global BUGFILE
            BUGFILE = cmd
            cmd = sys.argv[2]
            sys.argv.pop(0)

    except IndexError:
        cmd = 'list'
        args = []
    else:
        args = sys.argv[2:]

    handler = FileHandler()

    fn = globals().get('cmd_' + cmd) # find function matching command

    if fn is not None:
        fn(handler, *args)
    else:
        print("\nSyntax: %s [filename.rst] [command]\n" % sys.argv[0])

        docs = """\
    list: short listing of bugs (default action)
    show: [bug id] | detailed listing of bugs, ReStructuredText format (save as .rst or .txt)
    html: same as above, but in html format
    pull: [bug id]+ pull all JIRA bugs or only the specified ones
   serve: publish the html content using HTTP server
     new: open a new bug
      rm: [bug id] | remove some bug (mark as fixed)
     add: [bug id] | add some comment to a bug
   start: [bug id] | starts counting elapsed time for this bug
    stop: [bug id] | stops counting elapsed time for this bug
     tag: [bug id] [tag name] OR [tag name] | adds a tag to a bug OR list matching tickets
   untag: [bug id] [tag name] | removes a tag
     get: [bug id] [attr name] | prints an attribute value
     set: [bug id] [attr name] [value] | adds an attribute to a bug
   unset: [bug id] [attr name] | removes an attribute
    grep: [pattern] | list bugs containing given pattern(s)"""
        for doc in docs.split('\n'):
            name, desc = doc.split(': ', 1)
            if ' | ' in desc:
                args, desc = desc.split(' | ', 1)
                args = args
                desc = ' ' + desc
            else:
                args = ''
            print("%s %s%s" % (styled(name, YELLOW), args, styled(desc, 'blue')))

def get_jira_object():
    import getpass
    from six.moves import configparser
    from six.moves import input
    from jira import JIRA

    conf = jira_config_get(os.path.expanduser('~/.jiracli.ini'))
    options = {
        'server': conf.get('defaults', 'url'),
        'verify': True,
    }
    return JIRA(options, basic_auth=(conf.get('defaults', 'user'),
                                     conf.get('defaults', 'password')))


# Following code is a copy of jiracli/config.py file
# Copyright 2017 Thomas Bechtold <thomasbechtold@jpberlin.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import getpass
import os

from six.moves import configparser
from six.moves import input


def _config_credentials_get():
    """get username, password and url"""
    user = input("username:")
    password = getpass.getpass()
    url = input("url:")
    return user, password, url


def jira_config_get(config_path):
    """get the configuration"""
    conf = configparser.RawConfigParser()
    conf.read([config_path])
    section_name = "defaults"
    if 'RESETLOGIN' in os.environ:
        conf.remove_section(section_name)
    if not conf.has_section(section_name):
        user, password, url = _config_credentials_get()
        conf.add_section(section_name)
        conf.set(section_name, "user", user)
        conf.set(section_name, "password", password)
        conf.set(section_name, "url", url)
        with os.fdopen(os.open(
                config_path, os.O_WRONLY | os.O_CREAT, 0o600), 'w') as f:
            conf.write(f)

    # some people prefer to not store the password on disk, so
    # ask every time for the password
    if not conf.has_option(section_name, "password"):
        password = getpass.getpass()
        conf.set(section_name, "password", password)

    # some optional configuration options
    if not conf.has_option(section_name, "verify"):
        conf.set(section_name, "verify", "true")

    return conf

# jiracli code ends here

if __name__ == '__main__':
    if DEBUG:
        main()
        raise SystemExit(0)
    try:
        main()
    except RuntimeError as e:
        print(u'ERROR: ' + u' '.join(e.args))
    except ValueError as e:
        print(u'ERROR: Argument have incorrect value')
    except TypeError as e:
        print(u'ERROR: %s' % e.args[0].split(' ', 1)[1])
